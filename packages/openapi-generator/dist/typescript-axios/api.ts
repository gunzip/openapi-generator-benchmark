/* tslint:disable */
/* eslint-disable */
/**
 * Test API
 * Test API.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AllOfTest
 */
export interface AllOfTest {
    /**
     * Number of items returned for each page.
     * @type {number}
     * @memberof AllOfTest
     */
    'page_size'?: number;
    /**
     * Contains an URL to GET the next #<page_size> results in the retrieved collection of items.
     * @type {string}
     * @memberof AllOfTest
     */
    'next'?: string;
    /**
     * 
     * @type {Array<Message>}
     * @memberof AllOfTest
     */
    'items'?: Array<Message>;
}
/**
 * test if we can use allOf with just one element inside
 * @export
 * @interface AllOfWithOneElementTest
 */
export interface AllOfWithOneElementTest {
    /**
     * 
     * @type {string}
     * @memberof AllOfWithOneElementTest
     */
    'key'?: string;
}
/**
 * test if we can use allOf with just ref one element inside
 * @export
 * @interface AllOfWithOneRefElementTest
 */
export interface AllOfWithOneRefElementTest {
    /**
     * 
     * @type {string}
     * @memberof AllOfWithOneRefElementTest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AllOfWithOneRefElementTest
     */
    'family_name': string;
    /**
     * User\'s fiscal code.
     * @type {string}
     * @memberof AllOfWithOneRefElementTest
     */
    'fiscal_code': string;
    /**
     * 
     * @type {boolean}
     * @memberof AllOfWithOneRefElementTest
     */
    'has_profile': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AllOfWithOneRefElementTest
     */
    'is_email_set': boolean;
    /**
     * True if the recipient of a message wants to store its content for later retrieval.
     * @type {boolean}
     * @memberof AllOfWithOneRefElementTest
     */
    'is_inbox_enabled'?: boolean;
    /**
     * True if the recipient of a message wants to forward the notifications to the default webhook.
     * @type {boolean}
     * @memberof AllOfWithOneRefElementTest
     */
    'is_webhook_enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AllOfWithOneRefElementTest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AllOfWithOneRefElementTest
     */
    'preferred_email'?: string;
    /**
     * Indicates the User\'s preferred written or spoken languages in order of preference. Generally used for selecting a localized User interface. Valid values are concatenation of the ISO 639-1 two letter language code, an underscore, and the ISO 3166-1 2 letter country code; e.g., \'en_US\' specifies the language English and country US.
     * @type {Array<string>}
     * @memberof AllOfWithOneRefElementTest
     */
    'preferred_languages'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof AllOfWithOneRefElementTest
     */
    'version': number;
    /**
     * 
     * @type {object}
     * @memberof AllOfWithOneRefElementTest
     */
    'payload'?: object;
}
/**
 * test if allOf with x-extensible-enum works fine
 * @export
 * @interface AllOfWithXExtensibleEnum
 */
export interface AllOfWithXExtensibleEnum {
    /**
     * 
     * @type {string}
     * @memberof AllOfWithXExtensibleEnum
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AllOfWithXExtensibleEnum
     */
    'family_name': string;
    /**
     * User\'s fiscal code.
     * @type {string}
     * @memberof AllOfWithXExtensibleEnum
     */
    'fiscal_code': string;
    /**
     * 
     * @type {boolean}
     * @memberof AllOfWithXExtensibleEnum
     */
    'has_profile': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AllOfWithXExtensibleEnum
     */
    'is_email_set': boolean;
    /**
     * True if the recipient of a message wants to store its content for later retrieval.
     * @type {boolean}
     * @memberof AllOfWithXExtensibleEnum
     */
    'is_inbox_enabled'?: boolean;
    /**
     * True if the recipient of a message wants to forward the notifications to the default webhook.
     * @type {boolean}
     * @memberof AllOfWithXExtensibleEnum
     */
    'is_webhook_enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AllOfWithXExtensibleEnum
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AllOfWithXExtensibleEnum
     */
    'preferred_email'?: string;
    /**
     * Indicates the User\'s preferred written or spoken languages in order of preference. Generally used for selecting a localized User interface. Valid values are concatenation of the ISO 639-1 two letter language code, an underscore, and the ISO 3166-1 2 letter country code; e.g., \'en_US\' specifies the language English and country US.
     * @type {Array<string>}
     * @memberof AllOfWithXExtensibleEnum
     */
    'preferred_languages'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof AllOfWithXExtensibleEnum
     */
    'version': number;
    /**
     * 
     * @type {object}
     * @memberof AllOfWithXExtensibleEnum
     */
    'payload'?: object;
    /**
     * 
     * @type {string}
     * @memberof AllOfWithXExtensibleEnum
     */
    'status': string;
}
/**
 * What if a object has a field named items? The case is an object like { items: [] }, which is legal
 * @export
 * @interface AnObjectWithAnItemsField
 */
export interface AnObjectWithAnItemsField {
    /**
     * 
     * @type {Array<DefinitionFieldWithDash>}
     * @memberof AnObjectWithAnItemsField
     */
    'items': Array<DefinitionFieldWithDash>;
}
/**
 * Describes an object with a ref import
 * @export
 * @interface AnObjectWithRefImport
 */
export interface AnObjectWithRefImport {
    /**
     * 
     * @type {SimpleDefinition}
     * @memberof AnObjectWithRefImport
     */
    'prop1': SimpleDefinition;
}
/**
 * 
 * @export
 * @interface Book
 */
export interface Book {
    /**
     * title of the book
     * @type {string}
     * @memberof Book
     */
    'title'?: string;
    /**
     * 
     * @type {BookAuthor}
     * @memberof Book
     */
    'author'?: BookAuthor;
}
/**
 * 
 * @export
 * @interface BookAuthor
 */
export interface BookAuthor {
    /**
     * 
     * @type {boolean}
     * @memberof BookAuthor
     */
    'isDead'?: boolean;
    /**
     * 
     * @type {BookAuthorInfo}
     * @memberof BookAuthor
     */
    'info'?: BookAuthorInfo;
}
/**
 * 
 * @export
 * @interface BookAuthorInfo
 */
export interface BookAuthorInfo {
    /**
     * name of the person
     * @type {string}
     * @memberof BookAuthorInfo
     */
    'name'?: string;
    /**
     * 
     * @type {PersonAddress}
     * @memberof BookAuthorInfo
     */
    'address'?: PersonAddress;
    /**
     * 
     * @type {string}
     * @memberof BookAuthorInfo
     */
    'birth'?: string;
    /**
     * 
     * @type {string}
     * @memberof BookAuthorInfo
     */
    'death'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ConstantIntegerTest = {
    NUMBER_100: 100
} as const;

export type ConstantIntegerTest = typeof ConstantIntegerTest[keyof typeof ConstantIntegerTest];


/**
 * 
 * @export
 * @interface DefinitionFieldWithDash
 */
export interface DefinitionFieldWithDash {
    /**
     * 
     * @type {string}
     * @memberof DefinitionFieldWithDash
     */
    'id-field'?: string;
}
/**
 * 
 * @export
 * @interface DisabledUserTest
 */
export interface DisabledUserTest {
    /**
     * 
     * @type {boolean}
     * @memberof DisabledUserTest
     */
    'enabled': DisabledUserTestEnabledEnum;
    /**
     * 
     * @type {string}
     * @memberof DisabledUserTest
     */
    'reason': string;
    /**
     * 
     * @type {string}
     * @memberof DisabledUserTest
     */
    'username': string;
}

export const DisabledUserTestEnabledEnum = {
    False: false
} as const;

export type DisabledUserTestEnabledEnum = typeof DisabledUserTestEnabledEnum[keyof typeof DisabledUserTestEnabledEnum];

/**
 * @type DisjointUnionsUserTest
 * @export
 */
export type DisjointUnionsUserTest = DisabledUserTest | EnabledUserTest;

/**
 * 
 * @export
 * @interface EnabledUserTest
 */
export interface EnabledUserTest {
    /**
     * 
     * @type {string}
     * @memberof EnabledUserTest
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof EnabledUserTest
     */
    'enabled': EnabledUserTestEnabledEnum;
    /**
     * 
     * @type {string}
     * @memberof EnabledUserTest
     */
    'username': string;
}

export const EnabledUserTestEnabledEnum = {
    True: true
} as const;

export type EnabledUserTestEnabledEnum = typeof EnabledUserTestEnabledEnum[keyof typeof EnabledUserTestEnabledEnum];

/**
 * 
 * @export
 * @interface EnumFalseTest
 */
export interface EnumFalseTest {
    /**
     * 
     * @type {boolean}
     * @memberof EnumFalseTest
     */
    'flag'?: EnumFalseTestFlagEnum;
}

export const EnumFalseTestFlagEnum = {
    False: false
} as const;

export type EnumFalseTestFlagEnum = typeof EnumFalseTestFlagEnum[keyof typeof EnumFalseTestFlagEnum];

/**
 * 
 * @export
 * @interface EnumTest
 */
export interface EnumTest {
    /**
     * 
     * @type {string}
     * @memberof EnumTest
     */
    'status'?: EnumTestStatusEnum;
}

export const EnumTestStatusEnum = {
    Value1: 'value1',
    Value2: 'value2',
    Value3: 'value3'
} as const;

export type EnumTestStatusEnum = typeof EnumTestStatusEnum[keyof typeof EnumTestStatusEnum];

/**
 * 
 * @export
 * @interface EnumTrueTest
 */
export interface EnumTrueTest {
    /**
     * 
     * @type {boolean}
     * @memberof EnumTrueTest
     */
    'flag'?: EnumTrueTestFlagEnum;
}

export const EnumTrueTestFlagEnum = {
    True: true
} as const;

export type EnumTrueTestFlagEnum = typeof EnumTrueTestFlagEnum[keyof typeof EnumTrueTestFlagEnum];

/**
 * 
 * @export
 * @interface InlinePropertyTest
 */
export interface InlinePropertyTest {
    /**
     * The device global unique identifier.
     * @type {string}
     * @memberof InlinePropertyTest
     */
    'inlineProp'?: string;
}
/**
 * 
 * @export
 * @interface ListOfDefinitionsInner
 */
export interface ListOfDefinitionsInner {
    /**
     * 
     * @type {string}
     * @memberof ListOfDefinitionsInner
     */
    'field'?: string;
}
/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'id': string;
    /**
     * 
     * @type {MessageContent}
     * @memberof Message
     */
    'content': MessageContent;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'sender_service_id'?: string;
}
/**
 * 
 * @export
 * @interface MessageContent
 */
export interface MessageContent {
    /**
     * The (optional) subject of the message - note that only some notification channels support the display of a subject. When a subject is not provided, one gets generated from the client attributes.
     * @type {string}
     * @memberof MessageContent
     */
    'subject'?: string;
    /**
     * The full version of the message, in plain text or Markdown format. The content of this field will be delivered to channels that don\'t have any limit in terms of content size (e.g. email, etc...).
     * @type {string}
     * @memberof MessageContent
     */
    'markdown': string;
}
/**
 * 
 * @export
 * @interface NestedObjectTest
 */
export interface NestedObjectTest {
    /**
     * The device global unique identifier.
     * @type {string}
     * @memberof NestedObjectTest
     */
    'inlineProp'?: string;
    /**
     * 
     * @type {NestedObjectTestNestedObject}
     * @memberof NestedObjectTest
     */
    'nestedObject'?: NestedObjectTestNestedObject;
}
/**
 * 
 * @export
 * @interface NestedObjectTestNestedObject
 */
export interface NestedObjectTestNestedObject {
    /**
     * The device global unique identifier.
     * @type {string}
     * @memberof NestedObjectTestNestedObject
     */
    'inlineProp'?: string;
}
/**
 * 
 * @export
 * @interface NewModel
 */
export interface NewModel {
    /**
     * 
     * @type {string}
     * @memberof NewModel
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NewModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ObjectDefinitionWithImplicitType
 */
export interface ObjectDefinitionWithImplicitType {
    /**
     * 
     * @type {string}
     * @memberof ObjectDefinitionWithImplicitType
     */
    'prop_one'?: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectDefinitionWithImplicitType
     */
    'prop_two'?: string;
}
/**
 * @type OneOfTest
 * @export
 */
export type OneOfTest = OneOfTestOneOf | OneOfTestOneOf1;

/**
 * 
 * @export
 * @interface OneOfTestOneOf
 */
export interface OneOfTestOneOf {
    /**
     * 
     * @type {boolean}
     * @memberof OneOfTestOneOf
     */
    'limited'?: boolean;
}
/**
 * 
 * @export
 * @interface OneOfTestOneOf1
 */
export interface OneOfTestOneOf1 {
    /**
     * 
     * @type {boolean}
     * @memberof OneOfTestOneOf1
     */
    'unlimited'?: boolean;
}
/**
 * Pagination response parameters.
 * @export
 * @interface PaginationResponse
 */
export interface PaginationResponse {
    /**
     * Number of items returned for each page.
     * @type {number}
     * @memberof PaginationResponse
     */
    'page_size'?: number;
    /**
     * Contains an URL to GET the next #<page_size> results in the retrieved collection of items.
     * @type {string}
     * @memberof PaginationResponse
     */
    'next'?: string;
}
/**
 * 
 * @export
 * @interface Person
 */
export interface Person {
    /**
     * name of the person
     * @type {string}
     * @memberof Person
     */
    'name'?: string;
    /**
     * 
     * @type {PersonAddress}
     * @memberof Person
     */
    'address'?: PersonAddress;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'birth'?: string;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'death'?: string;
}
/**
 * 
 * @export
 * @interface PersonAddress
 */
export interface PersonAddress {
    /**
     * 
     * @type {string}
     * @memberof PersonAddress
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonAddress
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonAddress
     */
    'zipCode'?: string;
}
/**
 * Describes the user\'s profile.
 * @export
 * @interface Profile
 */
export interface Profile {
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'family_name': string;
    /**
     * User\'s fiscal code.
     * @type {string}
     * @memberof Profile
     */
    'fiscal_code': string;
    /**
     * 
     * @type {boolean}
     * @memberof Profile
     */
    'has_profile': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Profile
     */
    'is_email_set': boolean;
    /**
     * True if the recipient of a message wants to store its content for later retrieval.
     * @type {boolean}
     * @memberof Profile
     */
    'is_inbox_enabled'?: boolean;
    /**
     * True if the recipient of a message wants to forward the notifications to the default webhook.
     * @type {boolean}
     * @memberof Profile
     */
    'is_webhook_enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'preferred_email'?: string;
    /**
     * Indicates the User\'s preferred written or spoken languages in order of preference. Generally used for selecting a localized User interface. Valid values are concatenation of the ISO 639-1 two letter language code, an underscore, and the ISO 3166-1 2 letter country code; e.g., \'en_US\' specifies the language English and country US.
     * @type {Array<string>}
     * @memberof Profile
     */
    'preferred_languages'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Profile
     */
    'version': number;
    /**
     * 
     * @type {object}
     * @memberof Profile
     */
    'payload'?: object;
}
/**
 * 
 * @export
 * @interface SimpleDefinition
 */
export interface SimpleDefinition {
    /**
     * 
     * @type {string}
     * @memberof SimpleDefinition
     */
    'id': string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {NewModel} [newModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTestParameterWithBodyReference: async (newModel?: NewModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/put-test-parameter-with-body-ref`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} qr 
         * @param {string} [qo] 
         * @param {string} [cursor] An opaque identifier that points to the next item in the collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAuthBearer: async (qr: string, qo?: string, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'qr' is not null or undefined
            assertParamExists('testAuthBearer', 'qr', qr)
            const localVarPath = `/test-auth-bearer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (qo !== undefined) {
                localVarQueryParameter['qo'] = qo;
            }

            if (qr !== undefined) {
                localVarQueryParameter['qr'] = qr;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} qr 
         * @param {string} [qo] 
         * @param {string} [cursor] An opaque identifier that points to the next item in the collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAuthBearerHttp: async (qr: string, qo?: string, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'qr' is not null or undefined
            assertParamExists('testAuthBearerHttp', 'qr', qr)
            const localVarPath = `/test-auth-bearer-http`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerTokenHttp required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (qo !== undefined) {
                localVarQueryParameter['qo'] = qo;
            }

            if (qr !== undefined) {
                localVarQueryParameter['qr'] = qr;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testBinaryFileDownload: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/test-binary-file-download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testBinaryFileUpload: async (file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/test-binary-file-upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testCustomTokenHeader: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/test-custom-token-header`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication customToken required
            await setApiKeyToObject(localVarHeaderParameter, "custom-token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDates: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/test-dates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testFileUpload: async (file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/test-file-upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [param] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testHeaderOptional: async (param?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/test-header-optional`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (param != null) {
                localVarHeaderParameter['param'] = String(param);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} param 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testHeaderWithSchemaRef: async (param: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'param' is not null or undefined
            assertParamExists('testHeaderWithSchemaRef', 'param', param)
            const localVarPath = `/test-header-with-schema-ref`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (param != null) {
                localVarHeaderParameter['param'] = String(param);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testMultipleSuccess: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/test-multiple-success`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} param 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testParamWithSchemaRef: async (param: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'param' is not null or undefined
            assertParamExists('testParamWithSchemaRef', 'param', param)
            const localVarPath = `/test-param-with-schema-ref/{param}`
                .replace(`{${"param"}}`, encodeURIComponent(String(param)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NewModel} [newModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testParameterWithBodyReference: async (newModel?: NewModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/test-parameter-with-body-ref`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} pathParam 
         * @param {string} headerInlineParam 
         * @param {string} xHeaderParam A header param which has dashes in it
         * @param {string} [fooBar] 
         * @param {string} [requestId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testParameterWithDash: async (pathParam: string, headerInlineParam: string, xHeaderParam: string, fooBar?: string, requestId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pathParam' is not null or undefined
            assertParamExists('testParameterWithDash', 'pathParam', pathParam)
            // verify required parameter 'headerInlineParam' is not null or undefined
            assertParamExists('testParameterWithDash', 'headerInlineParam', headerInlineParam)
            // verify required parameter 'xHeaderParam' is not null or undefined
            assertParamExists('testParameterWithDash', 'xHeaderParam', xHeaderParam)
            const localVarPath = `/test-parameter-with-dash/{path-param}`
                .replace(`{${"path-param"}}`, encodeURIComponent(String(pathParam)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fooBar !== undefined) {
                localVarQueryParameter['foo-bar'] = fooBar;
            }

            if (requestId !== undefined) {
                localVarQueryParameter['request-id'] = requestId;
            }

            if (headerInlineParam != null) {
                localVarHeaderParameter['headerInlineParam'] = String(headerInlineParam);
            }

            if (xHeaderParam != null) {
                localVarHeaderParameter['x-header-param'] = String(xHeaderParam);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} pathParam 
         * @param {string} headerInlineParam 
         * @param {string} xHeaderParam A header param which has dashes in it
         * @param {string} [fooBar] 
         * @param {string} [requestId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testParameterWithDashAnUnderscore: async (pathParam: string, headerInlineParam: string, xHeaderParam: string, fooBar?: string, requestId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pathParam' is not null or undefined
            assertParamExists('testParameterWithDashAnUnderscore', 'pathParam', pathParam)
            // verify required parameter 'headerInlineParam' is not null or undefined
            assertParamExists('testParameterWithDashAnUnderscore', 'headerInlineParam', headerInlineParam)
            // verify required parameter 'xHeaderParam' is not null or undefined
            assertParamExists('testParameterWithDashAnUnderscore', 'xHeaderParam', xHeaderParam)
            const localVarPath = `/test-parameter-with-dash-and_underscore/{path-param}`
                .replace(`{${"path-param"}}`, encodeURIComponent(String(pathParam)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fooBar !== undefined) {
                localVarQueryParameter['foo_bar'] = fooBar;
            }

            if (requestId !== undefined) {
                localVarQueryParameter['request-id'] = requestId;
            }

            if (headerInlineParam != null) {
                localVarHeaderParameter['headerInlineParam'] = String(headerInlineParam);
            }

            if (xHeaderParam != null) {
                localVarHeaderParameter['x-header-param'] = String(xHeaderParam);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [requestId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testParameterWithReference: async (requestId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/test-parameter-with-reference`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestId !== undefined) {
                localVarQueryParameter['request-id'] = requestId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * when we declare parameters at path level
         * @param {string} requestId 
         * @param {string} [cursor] An opaque identifier that points to the next item in the collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testParametersAtPathLevel: async (requestId: string, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('testParametersAtPathLevel', 'requestId', requestId)
            const localVarPath = `/test-path-level-parameter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestId !== undefined) {
                localVarQueryParameter['request-id'] = requestId;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testResponseHeader: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/test-response-header`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * simply test of patch endpoint are considered
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testSimplePatch: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/test-simple`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} qr 
         * @param {string} [qo] 
         * @param {string} [cursor] An opaque identifier that points to the next item in the collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testSimpleToken: async (qr: string, qo?: string, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'qr' is not null or undefined
            assertParamExists('testSimpleToken', 'qr', qr)
            const localVarPath = `/test-simple-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication simpleToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-Functions-Key", configuration)

            if (qo !== undefined) {
                localVarQueryParameter['qo'] = qo;
            }

            if (qr !== undefined) {
                localVarQueryParameter['qr'] = qr;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testWithEmptyResponse: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/test-with-empty-response`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} firstParam 
         * @param {string} secondParam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testWithTwoParams: async (firstParam: string, secondParam: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'firstParam' is not null or undefined
            assertParamExists('testWithTwoParams', 'firstParam', firstParam)
            // verify required parameter 'secondParam' is not null or undefined
            assertParamExists('testWithTwoParams', 'secondParam', secondParam)
            const localVarPath = `/test-two-path-params/{first-param}/{second-param}`
                .replace(`{${"first-param"}}`, encodeURIComponent(String(firstParam)))
                .replace(`{${"second-param"}}`, encodeURIComponent(String(secondParam)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {NewModel} [newModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putTestParameterWithBodyReference(newModel?: NewModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putTestParameterWithBodyReference(newModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.putTestParameterWithBodyReference']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} qr 
         * @param {string} [qo] 
         * @param {string} [cursor] An opaque identifier that points to the next item in the collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testAuthBearer(qr: string, qo?: string, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testAuthBearer(qr, qo, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.testAuthBearer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} qr 
         * @param {string} [qo] 
         * @param {string} [cursor] An opaque identifier that points to the next item in the collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testAuthBearerHttp(qr: string, qo?: string, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testAuthBearerHttp(qr, qo, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.testAuthBearerHttp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testBinaryFileDownload(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testBinaryFileDownload(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.testBinaryFileDownload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testBinaryFileUpload(file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testBinaryFileUpload(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.testBinaryFileUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testCustomTokenHeader(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testCustomTokenHeader(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.testCustomTokenHeader']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testDates(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Person>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testDates(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.testDates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testFileUpload(file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testFileUpload(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.testFileUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [param] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testHeaderOptional(param?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testHeaderOptional(param, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.testHeaderOptional']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} param 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testHeaderWithSchemaRef(param: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testHeaderWithSchemaRef(param, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.testHeaderWithSchemaRef']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testMultipleSuccess(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testMultipleSuccess(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.testMultipleSuccess']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} param 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testParamWithSchemaRef(param: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testParamWithSchemaRef(param, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.testParamWithSchemaRef']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {NewModel} [newModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testParameterWithBodyReference(newModel?: NewModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testParameterWithBodyReference(newModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.testParameterWithBodyReference']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} pathParam 
         * @param {string} headerInlineParam 
         * @param {string} xHeaderParam A header param which has dashes in it
         * @param {string} [fooBar] 
         * @param {string} [requestId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testParameterWithDash(pathParam: string, headerInlineParam: string, xHeaderParam: string, fooBar?: string, requestId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testParameterWithDash(pathParam, headerInlineParam, xHeaderParam, fooBar, requestId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.testParameterWithDash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} pathParam 
         * @param {string} headerInlineParam 
         * @param {string} xHeaderParam A header param which has dashes in it
         * @param {string} [fooBar] 
         * @param {string} [requestId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testParameterWithDashAnUnderscore(pathParam: string, headerInlineParam: string, xHeaderParam: string, fooBar?: string, requestId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testParameterWithDashAnUnderscore(pathParam, headerInlineParam, xHeaderParam, fooBar, requestId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.testParameterWithDashAnUnderscore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [requestId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testParameterWithReference(requestId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testParameterWithReference(requestId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.testParameterWithReference']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * when we declare parameters at path level
         * @param {string} requestId 
         * @param {string} [cursor] An opaque identifier that points to the next item in the collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testParametersAtPathLevel(requestId: string, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testParametersAtPathLevel(requestId, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.testParametersAtPathLevel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testResponseHeader(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testResponseHeader(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.testResponseHeader']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * simply test of patch endpoint are considered
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testSimplePatch(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testSimplePatch(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.testSimplePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} qr 
         * @param {string} [qo] 
         * @param {string} [cursor] An opaque identifier that points to the next item in the collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testSimpleToken(qr: string, qo?: string, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testSimpleToken(qr, qo, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.testSimpleToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testWithEmptyResponse(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testWithEmptyResponse(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.testWithEmptyResponse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} firstParam 
         * @param {string} secondParam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testWithTwoParams(firstParam: string, secondParam: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testWithTwoParams(firstParam, secondParam, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.testWithTwoParams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {NewModel} [newModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTestParameterWithBodyReference(newModel?: NewModel, options?: any): AxiosPromise<void> {
            return localVarFp.putTestParameterWithBodyReference(newModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} qr 
         * @param {string} [qo] 
         * @param {string} [cursor] An opaque identifier that points to the next item in the collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAuthBearer(qr: string, qo?: string, cursor?: string, options?: any): AxiosPromise<void> {
            return localVarFp.testAuthBearer(qr, qo, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} qr 
         * @param {string} [qo] 
         * @param {string} [cursor] An opaque identifier that points to the next item in the collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAuthBearerHttp(qr: string, qo?: string, cursor?: string, options?: any): AxiosPromise<void> {
            return localVarFp.testAuthBearerHttp(qr, qo, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testBinaryFileDownload(options?: any): AxiosPromise<File> {
            return localVarFp.testBinaryFileDownload(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testBinaryFileUpload(file?: File, options?: any): AxiosPromise<void> {
            return localVarFp.testBinaryFileUpload(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testCustomTokenHeader(options?: any): AxiosPromise<void> {
            return localVarFp.testCustomTokenHeader(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDates(options?: any): AxiosPromise<Person> {
            return localVarFp.testDates(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testFileUpload(file?: File, options?: any): AxiosPromise<void> {
            return localVarFp.testFileUpload(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [param] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testHeaderOptional(param?: string, options?: any): AxiosPromise<void> {
            return localVarFp.testHeaderOptional(param, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} param 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testHeaderWithSchemaRef(param: string, options?: any): AxiosPromise<void> {
            return localVarFp.testHeaderWithSchemaRef(param, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testMultipleSuccess(options?: any): AxiosPromise<Message> {
            return localVarFp.testMultipleSuccess(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} param 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testParamWithSchemaRef(param: string, options?: any): AxiosPromise<void> {
            return localVarFp.testParamWithSchemaRef(param, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {NewModel} [newModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testParameterWithBodyReference(newModel?: NewModel, options?: any): AxiosPromise<void> {
            return localVarFp.testParameterWithBodyReference(newModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} pathParam 
         * @param {string} headerInlineParam 
         * @param {string} xHeaderParam A header param which has dashes in it
         * @param {string} [fooBar] 
         * @param {string} [requestId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testParameterWithDash(pathParam: string, headerInlineParam: string, xHeaderParam: string, fooBar?: string, requestId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.testParameterWithDash(pathParam, headerInlineParam, xHeaderParam, fooBar, requestId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} pathParam 
         * @param {string} headerInlineParam 
         * @param {string} xHeaderParam A header param which has dashes in it
         * @param {string} [fooBar] 
         * @param {string} [requestId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testParameterWithDashAnUnderscore(pathParam: string, headerInlineParam: string, xHeaderParam: string, fooBar?: string, requestId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.testParameterWithDashAnUnderscore(pathParam, headerInlineParam, xHeaderParam, fooBar, requestId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [requestId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testParameterWithReference(requestId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.testParameterWithReference(requestId, options).then((request) => request(axios, basePath));
        },
        /**
         * when we declare parameters at path level
         * @param {string} requestId 
         * @param {string} [cursor] An opaque identifier that points to the next item in the collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testParametersAtPathLevel(requestId: string, cursor?: string, options?: any): AxiosPromise<void> {
            return localVarFp.testParametersAtPathLevel(requestId, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testResponseHeader(options?: any): AxiosPromise<Message> {
            return localVarFp.testResponseHeader(options).then((request) => request(axios, basePath));
        },
        /**
         * simply test of patch endpoint are considered
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testSimplePatch(options?: any): AxiosPromise<void> {
            return localVarFp.testSimplePatch(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} qr 
         * @param {string} [qo] 
         * @param {string} [cursor] An opaque identifier that points to the next item in the collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testSimpleToken(qr: string, qo?: string, cursor?: string, options?: any): AxiosPromise<void> {
            return localVarFp.testSimpleToken(qr, qo, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testWithEmptyResponse(options?: any): AxiosPromise<void> {
            return localVarFp.testWithEmptyResponse(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} firstParam 
         * @param {string} secondParam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testWithTwoParams(firstParam: string, secondParam: string, options?: any): AxiosPromise<void> {
            return localVarFp.testWithTwoParams(firstParam, secondParam, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {NewModel} [newModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putTestParameterWithBodyReference(newModel?: NewModel, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).putTestParameterWithBodyReference(newModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} qr 
     * @param {string} [qo] 
     * @param {string} [cursor] An opaque identifier that points to the next item in the collection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public testAuthBearer(qr: string, qo?: string, cursor?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).testAuthBearer(qr, qo, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} qr 
     * @param {string} [qo] 
     * @param {string} [cursor] An opaque identifier that points to the next item in the collection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public testAuthBearerHttp(qr: string, qo?: string, cursor?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).testAuthBearerHttp(qr, qo, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public testBinaryFileDownload(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).testBinaryFileDownload(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public testBinaryFileUpload(file?: File, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).testBinaryFileUpload(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public testCustomTokenHeader(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).testCustomTokenHeader(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public testDates(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).testDates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public testFileUpload(file?: File, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).testFileUpload(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [param] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public testHeaderOptional(param?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).testHeaderOptional(param, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} param 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public testHeaderWithSchemaRef(param: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).testHeaderWithSchemaRef(param, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public testMultipleSuccess(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).testMultipleSuccess(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} param 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public testParamWithSchemaRef(param: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).testParamWithSchemaRef(param, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {NewModel} [newModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public testParameterWithBodyReference(newModel?: NewModel, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).testParameterWithBodyReference(newModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} pathParam 
     * @param {string} headerInlineParam 
     * @param {string} xHeaderParam A header param which has dashes in it
     * @param {string} [fooBar] 
     * @param {string} [requestId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public testParameterWithDash(pathParam: string, headerInlineParam: string, xHeaderParam: string, fooBar?: string, requestId?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).testParameterWithDash(pathParam, headerInlineParam, xHeaderParam, fooBar, requestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} pathParam 
     * @param {string} headerInlineParam 
     * @param {string} xHeaderParam A header param which has dashes in it
     * @param {string} [fooBar] 
     * @param {string} [requestId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public testParameterWithDashAnUnderscore(pathParam: string, headerInlineParam: string, xHeaderParam: string, fooBar?: string, requestId?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).testParameterWithDashAnUnderscore(pathParam, headerInlineParam, xHeaderParam, fooBar, requestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [requestId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public testParameterWithReference(requestId?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).testParameterWithReference(requestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * when we declare parameters at path level
     * @param {string} requestId 
     * @param {string} [cursor] An opaque identifier that points to the next item in the collection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public testParametersAtPathLevel(requestId: string, cursor?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).testParametersAtPathLevel(requestId, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public testResponseHeader(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).testResponseHeader(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * simply test of patch endpoint are considered
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public testSimplePatch(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).testSimplePatch(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} qr 
     * @param {string} [qo] 
     * @param {string} [cursor] An opaque identifier that points to the next item in the collection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public testSimpleToken(qr: string, qo?: string, cursor?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).testSimpleToken(qr, qo, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public testWithEmptyResponse(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).testWithEmptyResponse(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} firstParam 
     * @param {string} secondParam 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public testWithTwoParams(firstParam: string, secondParam: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).testWithTwoParams(firstParam, secondParam, options).then((request) => request(this.axios, this.basePath));
    }
}



