// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

export const zPerson = z.object({
    name: z.optional(z.string()),
    address: z.optional(z.object({
        location: z.optional(z.string()),
        city: z.optional(z.string()),
        zipCode: z.optional(z.string().regex(/^\d{5}$/))
    })),
    birth: z.optional(z.iso.datetime()),
    death: z.optional(z.iso.date()),
    age: z.optional(z.unknown()),
    zipCode: z.optional(z.string().regex(/[0-9]+/))
});

export const zBook = z.object({
    title: z.optional(z.string()),
    author: z.optional(z.object({
        isDead: z.optional(z.boolean()),
        info: z.optional(zPerson)
    }))
});

/**
 * User's fiscal code.
 */
export const zFiscalCode = z.string().regex(/^[A-Z]{6}[0-9LMNPQRSTUV]{2}[ABCDEHLMPRST][0-9LMNPQRSTUV]{2}[A-Z][0-9LMNPQRSTUV]{3}[A-Z]$/);

export const zEmailAddress = z.email();

/**
 * True if the recipient of a message wants to store its content for later retrieval.
 */
export const zIsInboxEnabled = z.boolean().default(false);

/**
 * True if the recipient of a message wants to forward the notifications to the default webhook.
 */
export const zIsWebhookEnabled = z.boolean().default(false);

export const zPreferredLanguage = z.string();

/**
 * Indicates the User's preferred written or spoken languages in order of preference. Generally used for selecting a localized User interface. Valid values are concatenation of the ISO 639-1 two letter language code, an underscore, and the ISO 3166-1 2 letter country code; e.g., 'en_US' specifies the language English and country US.
 */
export const zPreferredLanguages = z.array(zPreferredLanguage);

/**
 * Profile
 * Describes the user's profile.
 */
export const zProfile = z.object({
    email: z.optional(zEmailAddress),
    family_name: z.string(),
    fiscal_code: zFiscalCode,
    has_profile: z.boolean(),
    is_email_set: z.boolean(),
    is_inbox_enabled: z.optional(zIsInboxEnabled),
    is_webhook_enabled: z.optional(zIsWebhookEnabled),
    name: z.string(),
    preferred_email: z.optional(zEmailAddress),
    preferred_languages: z.optional(zPreferredLanguages),
    version: z.int(),
    payload: z.optional(z.record(z.string(), z.unknown()))
});

/**
 * SimpleDefinition
 */
export const zSimpleDefinition = z.object({
    id: z.string()
});

export const zDefinitionFieldWithDash = z.object({
    'id-field': z.optional(z.string())
});

/**
 * The (optional) subject of the message - note that only some notification
 * channels support the display of a subject. When a subject is not provided,
 * one gets generated from the client attributes.
 */
export const zMessageSubject = z.string().min(10).max(120);

/**
 * The full version of the message, in plain text or Markdown format. The
 * content of this field will be delivered to channels that don't have any
 * limit in terms of content size (e.g. email, etc...).
 */
export const zMessageBodyMarkdown = z.string().min(80).max(10000);

export const zMessageContent = z.object({
    subject: z.optional(zMessageSubject),
    markdown: zMessageBodyMarkdown
});

/**
 * Message
 */
export const zMessage = z.object({
    id: z.string(),
    content: zMessageContent,
    sender_service_id: z.optional(z.string())
});

/**
 * NewModel
 */
export const zNewModel = z.object({
    id: z.string(),
    name: z.string()
});

/**
 * Pagination response parameters.
 */
export const zPaginationResponse = z.object({
    page_size: z.optional(z.int().gte(1)),
    next: z.optional(z.url())
});

export const zOneOfTest = z.union([
    z.object({
        limited: z.optional(z.boolean())
    }),
    z.object({
        unlimited: z.optional(z.boolean())
    })
]);

/**
 * test if we can use allOf with just one element inside
 */
export const zAllOfWithOneElementTest = z.object({
    key: z.optional(z.string())
});

/**
 * test if we can use allOf with just ref one element inside
 */
export const zAllOfWithOneRefElementTest = zProfile;

/**
 * test if allOf with x-extensible-enum works fine
 */
export const zAllOfWithXExtensibleEnum = zProfile.and(z.object({
    status: z.string()
}));

export const zAllOfTest = z.object({
    items: z.optional(z.array(zMessage))
}).and(zPaginationResponse);

/**
 * What if a object has a field named items?
 * The case is an object like { items: [] }, which is legal
 */
export const zAnObjectWithAnItemsField = z.object({
    items: z.array(zDefinitionFieldWithDash)
});

/**
 * AnObjectWithRefImport
 * Describes an object with a ref import
 */
export const zAnObjectWithRefImport = z.object({
    prop1: zSimpleDefinition
});

export const zTestDeserUser = z.object({
    name: z.string(),
    age: z.int()
});

/**
 * WithinRangeStringTest
 */
export const zWithinRangeStringTest = z.string().min(8).max(10);

/**
 * NonNegativeNumberTest
 */
export const zNonNegativeNumberTest = z.number().gte(0);

/**
 * ConstantIntegerTest
 */
export const zConstantIntegerTest = z.unknown();

/**
 * NonNegativeIntegerTest
 */
export const zNonNegativeIntegerTest = z.int().gte(0);

/**
 * WithinRangeIntegerTest
 */
export const zWithinRangeIntegerTest = z.int().gte(0).lte(10);

/**
 * WithinRangeNumberTest
 */
export const zWithinRangeNumberTest = z.number().gte(0).lte(10);

/**
 * WithinRangeExclusiveMaximumIntegerTest
 */
export const zWithinRangeExclusiveMaximumIntegerTest = z.int().gte(0).lt(10);

/**
 * WithinRangeExclusiveMinimumIntegerTest
 */
export const zWithinRangeExclusiveMinimumIntegerTest = z.int().gt(0).lte(10);

/**
 * WithinRangeExclusiveMinimumNumberTest
 */
export const zWithinRangeExclusiveMinimumNumberTest = z.number().gt(0).lte(10);

/**
 * WithinRangeExclusiveMinMaxIntegerTest
 */
export const zWithinRangeExclusiveMinMaxIntegerTest = z.number().gt(0).lt(10);

/**
 * WithinRangeExclusiveMinMaxNumberTest
 */
export const zWithinRangeExclusiveMinMaxNumberTest = z.number().gt(0).lt(10);

/**
 * WithinRangeExclusiveMaximumNumberTest
 */
export const zWithinRangeExclusiveMaximumNumberTest = z.number().gte(0).lt(10);

export const zCustomStringFormatTest = z.string();

export const zEnumTest = z.object({
    status: z.optional(z.enum([
        'value1',
        'value2',
        'value3'
    ]))
});

export const zAdditionalPropsTest = z.record(z.string(), z.array(z.number()));

export const zAdditionalPropsTrueTest = z.record(z.string(), z.unknown());

export const zAdditionalpropsDefault = z.record(z.string(), z.array(z.number())).default({
    test: [1000]
});

export const zInlinePropertyTest = z.object({
    inlineProp: z.optional(z.string().regex(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/))
});

export const zNestedObjectTest = z.object({
    inlineProp: z.optional(z.string().regex(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/)),
    nestedObject: z.optional(z.object({
        inlineProp: z.optional(z.string().regex(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/))
    }))
});

export const zOrganizationFiscalCode = z.string();

export const zOrganizationFiscalCodeTest = z.string();

/**
 * a definition which is a list of other definitions.
 */
export const zListOfDefinitions = z.array(z.object({
    field: z.optional(z.string())
}));

/**
 * a definition which is a list of references to other definitions.
 */
export const zListOfReferences = z.array(zDefinitionFieldWithDash);

export const zEnabledUserTest = z.object({
    description: z.string(),
    enabled: z.unknown(),
    username: z.string()
});

export const zDisabledUserTest = z.object({
    enabled: z.unknown(),
    reason: z.string(),
    username: z.string()
});

export const zDisjointUnionsUserTest = z.union([
    zEnabledUserTest,
    zDisabledUserTest
]);

export const zEnumTrueTest = z.object({
    flag: z.optional(z.unknown())
});

export const zEnumFalseTest = z.object({
    flag: z.optional(z.unknown())
});

export const zObjectDefinitionWithImplicitType = z.object({
    prop_one: z.optional(z.string()),
    prop_two: z.optional(z.string())
});

export const zObjectDefinitionWithImplicitTypeAndAdditionalProperties = z.unknown();

export const zProblemDetails = z.object({
    type: z.optional(z.url()),
    title: z.optional(z.string()),
    status: z.optional(z.int()),
    detail: z.optional(z.string()),
    instance: z.optional(z.url())
});

/**
 * An opaque identifier that points to the next item in the collection.
 */
export const zPaginationRequest = z.string();

export const zRequestId = z.string().min(10);

export const zRequiredRequestId = z.string();

/**
 * A header param which has dashes in it
 */
export const zHeaderParamWithReference = z.string();

export const zTestAuthBearerData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        qo: z.optional(z.string()),
        qr: z.string(),
        cursor: z.optional(z.string().min(1))
    })
});

/**
 * Will send `Authenticated`
 */
export const zTestAuthBearerResponse = zPerson;

export const zTestAuthBearerHttpData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        qo: z.optional(z.string()),
        qr: z.string(),
        cursor: z.optional(z.string().min(1))
    })
});

export const zTestSimpleTokenData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        qo: z.optional(z.string()),
        qr: z.string(),
        cursor: z.optional(z.string())
    })
});

export const zTestMultipleSuccessData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zTestMultipleSuccessResponse = z.union([
    zMessage,
    z.unknown()
]);

export const zTestFileUploadData = z.object({
    body: z.object({
        file: z.optional(z.string())
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zTestBinaryFileUploadData = z.object({
    body: z.object({
        file: z.optional(z.string())
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zTestBinaryFileDownloadData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Binary file download
 */
export const zTestBinaryFileDownloadResponse = z.string();

export const zTestResponseHeaderData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Will create a Message
 */
export const zTestResponseHeaderResponse = zMessage;

export const zTestParameterWithReferenceData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        'request-id': z.optional(z.string().min(10))
    }))
});

export const zTestInlineBodySchemaData = z.object({
    body: z.object({
        name: z.string(),
        age: z.optional(z.number())
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zTestParameterWithBodyReferenceData = z.object({
    body: z.optional(zNewModel),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zPutTestParameterWithBodyReferenceData = z.object({
    body: z.optional(zNewModel),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zTestParameterWithDashData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        'path-param': z.string().min(5)
    }),
    query: z.optional(z.object({
        'foo-bar': z.optional(z.string()),
        'request-id': z.optional(z.string().min(10))
    })),
    headers: z.object({
        headerInlineParam: z.string(),
        'x-header-param': z.string()
    })
});

export const zTestParameterWithDashAnUnderscoreData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        'path-param': z.string()
    }),
    query: z.optional(z.object({
        foo_bar: z.optional(z.string()),
        'request-id': z.optional(z.string().min(10))
    })),
    headers: z.object({
        headerInlineParam: z.string(),
        'x-header-param': z.string()
    })
});

export const zTestWithTwoParamsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        'first-param': z.string(),
        'second-param': z.string()
    }),
    query: z.optional(z.never())
});

export const zTestParametersAtPathLevelData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        'request-id': z.string(),
        cursor: z.optional(z.string())
    })
});

export const zTestSimplePatchData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zTestCustomTokenHeaderData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zTestWithEmptyResponseData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zTestParamWithSchemaRefData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        param: zCustomStringFormatTest
    }),
    query: z.optional(z.never())
});

export const zTestHeaderWithSchemaRefData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never()),
    headers: z.object({
        param: zCustomStringFormatTest
    })
});

export const zTestHeaderOptionalData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never()),
    headers: z.optional(z.object({
        param: z.optional(zCustomStringFormatTest)
    }))
});

export const zTestOverriddenSecurityData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zTestOverriddenSecurityNoAuthData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zTestMultiContentTypesData = z.object({
    body: zNewModel,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zTestMultiContentTypesResponse = z.union([
    zNewModel,
    zBook
]);

export const zTestDeserializationData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Ok
 */
export const zTestDeserializationResponse = zTestDeserUser;